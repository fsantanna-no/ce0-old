- como implementar cruzamento de escopo?
    - cruzou o "arg": retorna qtd de vezes que cruzou
- three crosses scope. fthree is setting it to pool

- verificar alocacoes em todos os exemplos
- estudar sobre avaliacao, tail call

- POOLS
    - testar nao caber no pool
    - id()
        func f: () -> Nat {
            val x: Nat = ...
            return id(x)    -- does not return x, but pass x to id which might return it
        }                   -- solution is to make x also go to the pool
        val x[] = f()
    - can't return tuples w/ multiple rec types

- RECS
    - remover keyword rec?
    - f : () -> (Nat,List)
    - x[]: (Nat,List) = f()
        - funcao retornar dois recs
        - mas o retorno tem que ser uma variavel sÃ³ que em teoria teria que guardar os dois recs no mesmo pool?

- MINOR
    - subtypes
        - val x: True = True
    - https://www.google.com/search?q=same-fringe+problem
        - https://www.lua.org/doc/jai2009.pdf
    - type Expr: (n:Int,env:Env) {
        Tuple: (size:Int, vec:[Expr])
        Stmt: (...)
      }
    - named tuples (struct/record) (Int,Int) --> (x:Int,y:Int)
    - input function polymorphic
    - -Wno-format-zero-length
    - types.c
        - verify duplicates for types/subtypes/vars/funcs
        - verify assigns, calls args/ret
    - funcoes as values (now we have ENV:var,func,type)
    - funcoes recursivas
        - special rec syntax
        - change env before body
    - assert no EXPR_DISC (gerar erro caso nao seja do subtipo certo)
    - type names must contain lowercase (error in C generation upper/lower)
    - output/input for strings, output_type/input_type for users
    - #define UNIT 1 // #define Unit int
    - repl
        - prevent side effect of expr to be lost:
            - _1 = exp ; output(_1);
        - >>> if not finished
    - Exceptions:
        - https://www.programmersought.com/article/404520682/
        - https://www.usenix.org/legacy/publications/library/proceedings/sa92/moen.pdf

- Ce0
    - implemented in C
    - simplest possible
    - immutable
- Ce
    - implemented in Ce0
    - mutable
    - type inference
    - pattern matching
    - lambdas
    - synchronous concurrency

void *heap_locations;
void *stack_location;

void determine_locations (int any_int) {
   free(heap_location = malloc(248));
   stack_location = &any_int;
}

int main(int argc, char *argv[]) {
  determine_locations(argc);
      .
      .
      .
  return 0;
}

<!--
- full previous


val y[]: Nat = Succ(f())

- further examples: add inside, add outside
```
func f: () -> Nat {
    val x: Nat = Succ(Succ(Nil))
    val y: Nat = Succ(Succ(Nil))
    val z: Nat = add(x,y)
    return z
}
val y[]: Nat = f()
```
```
func f: () -> Nat {
    val x: Nat = Succ(Succ(Nil))
    val y: Nat = Succ(Succ(Nil))
    val z: Nat = add(x,y)
    return z
}
val y[]: Nat = add(two,f())
```
-->
