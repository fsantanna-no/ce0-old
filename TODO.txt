- POOLS
    - como fazer track em code?
        - comecei pelo EXPR_CONS dentro de STMT_RETURN
            - depois tenho que ir atras dos EXPR_VAR
    - testar nao caber no pool
    - clean/free para tirar mleak do penultimo teste
        - fazer um com stack addr pra dar problema
    - gerar codigo dinamico para cons em return
    - Succ(f()) é problema? ou seja, cabeca estatico e cauda dinamico
    - id()
        func f: () -> Nat {
            val x: Nat = ...
            return id(x)    -- does not return x, but pass x to id which might return it
        }                   -- solution is to make x also go to the pool
        val x[] = f()

- RECS
    - f : () -> (Nat,List)
    - x[]: (Nat,List) = f()
        - funcao retornar dois recs
        - mas o retorno tem que ser uma variavel só que em teoria teria que guardar os dois recs no mesmo pool?

- MINOR
    - type Expr: (n:Int,env:Env) {
        Tuple: (size:Int, vec:[Expr])
        Stmt: (...)
      }
    - named tuples (struct/record) (Int,Int) --> (x:Int,y:Int)
    - input function polymorphic
    - -Wno-format-zero-length
    - types.c
        - verify duplicates for types/subtypes/vars/funcs
        - verify assigns, calls args/ret
    - funcoes as values (now we have ENV:var,func,type)
    - funcoes recursivas
        - special rec syntax
        - change env before body
    - assert no EXPR_DISC (gerar erro caso nao seja do subtipo certo)
    - type names must contain lowercase (error in C generation upper/lower)
    - output/input for strings, output_type/input_type for users
    - #define UNIT 1 // #define Unit int
    - Heap vs Stack:
        - https://stackoverflow.com/questions/8385322/difference-between-static-memory-allocation-and-dynamic-memory-allocation
    - Cleanup
        - http://echorand.me/site/notes/articles/c_cleanup/cleanup_attribute_c.html
    - repl
        - prevent side effect of expr to be lost:
            - _1 = exp ; output(_1);
        - >>> if not finished
    - Exceptions:
        - https://www.programmersought.com/article/404520682/
        - https://www.usenix.org/legacy/publications/library/proceedings/sa92/moen.pdf

- Ce0
    - implemented in C
    - simplest possible
    - immutable
- Ce
    - implemented in Ce0
    - mutable
    - type inference
    - pattern matching
    - lambdas
    - synchronous concurrency

void *heap_locations;
void *stack_location;

void determine_locations (int any_int) {
   free(heap_location = malloc(248));
   stack_location = &any_int;
}

int main(int argc, char *argv[]) {
  determine_locations(argc);
      .
      .
      .
  return 0;
}

<!--
- full previous


val y[]: Nat = Succ(f())

- further examples: add inside, add outside
```
func f: () -> Nat {
    val x: Nat = Succ(Succ(Nil))
    val y: Nat = Succ(Succ(Nil))
    val z: Nat = add(x,y)
    return z
}
val y[]: Nat = f()
```
```
func f: () -> Nat {
    val x: Nat = Succ(Succ(Nil))
    val y: Nat = Succ(Succ(Nil))
    val z: Nat = add(x,y)
    return z
}
val y[]: Nat = add(two,f())
```
-->
