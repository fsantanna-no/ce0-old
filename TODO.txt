- var, swap semantics, finalize que so testa NULL ou free, nao precisa de fat pointer
- copy: nao precisa
    - func two: Nat { return Succ(one()) };
- STMT_SET
- ref x: Nat
    - lista na pilha que deve ser percorrida sempre que ha um free


- ./ce.out double free
    - quando REC_CONS é passado pra arg, zero bit, quando retorno, seto o bit
- agora declarar todas as refs como struct ref e initializar como REC_ALIAS/REC_CONS.
    - no caso de REC_CONS setar bit e apontar, no case de REC_ALIAS apontar pra REC_CONS
- erro ao compartilhar refs de malloc pools diferentes
- DINAMICO detectar quando ponteiros nao sao retornados e assim desalocar sua arvore na saida
- verificar alocacoes em todos os exemplos
- estudar sobre avaliacao, tail call

- POOLS
    - testar nao caber no pool
    - id()
        func f: () -> Nat {
            val x: Nat = ...
            return id(x)    -- does not return x, but pass x to id which might return it
        }                   -- solution is to make x also go to the pool
        val x[] = f()
    - can't return tuples w/ multiple rec types
    -- TODO-1: warning minor issue

- RECS
    - remover keyword rec?
    - f : () -> (Nat,List)
    - x[]: (Nat,List) = f()
        - funcao retornar dois recs
        - mas o retorno tem que ser uma variavel só que em teoria teria que guardar os dois recs no mesmo pool?

- MINOR
    - subtypes
        - val x: True = True
    - https://www.google.com/search?q=same-fringe+problem
        - https://www.lua.org/doc/jai2009.pdf
    - type Expr: (n:Int,env:Env) {
        Tuple: (size:Int, vec:[Expr])
        Stmt: (...)
      }
    - named tuples (struct/record) (Int,Int) --> (x:Int,y:Int)
    - input function polymorphic
    - -Wno-format-zero-length
    - types.c
        - verify duplicates for types/subtypes/vars/funcs
        - verify assigns, calls args/ret
    - funcoes as values (now we have ENV:var,func,type)
    - funcoes recursivas
        - special rec syntax
        - change env before body
    - assert no EXPR_DISC (gerar erro caso nao seja do subtipo certo)
    - type names must contain lowercase (error in C generation upper/lower)
    - output/input for strings, output_type/input_type for users
    - #define UNIT 1 // #define Unit int
    - repl
        - prevent side effect of expr to be lost:
            - _1 = exp ; output(_1);
        - >>> if not finished
    - Exceptions:
        - https://www.programmersought.com/article/404520682/
        - https://www.usenix.org/legacy/publications/library/proceedings/sa92/moen.pdf

- Ce0
    - implemented in C
    - simplest possible
    - immutable
- Ce
    - implemented in Ce0
    - mutable
    - type inference
    - pattern matching
    - lambdas
    - synchronous concurrency

void *heap_locations;
void *stack_location;

void determine_locations (int any_int) {
   free(heap_location = malloc(248));
   stack_location = &any_int;
}

int main(int argc, char *argv[]) {
  determine_locations(argc);
      .
      .
      .
  return 0;
}

<!--
- full previous


val y[]: Nat = Succ(f())

- further examples: add inside, add outside
```
func f: () -> Nat {
    val x: Nat = Succ(Succ(Nil))
    val y: Nat = Succ(Succ(Nil))
    val z: Nat = add(x,y)
    return z
}
val y[]: Nat = f()
```
```
func f: () -> Nat {
    val x: Nat = Succ(Succ(Nil))
    val y: Nat = Succ(Succ(Nil))
    val z: Nat = add(x,y)
    return z
}
val y[]: Nat = add(two,f())
```
-->

-- DINAMICO detectar quando ponteiros nao sao retornados e assim desalocar sua arvore na saida

func max: (Nat,Nat) -> Nat {
    -- arg e x e y sao gordos, todos com bit desligado
    val x: Nat = arg.1  -- no cleanup eu testo o bit e desaloco geral se tiver desligado
    val y: Nat = arg.2
    if x > y {
        return x        -- x+1 (liga bit)
    } else {
        return y        -- y+1 (liga bit)
    }
}

x = max(2,3)    -- 2 e 3 ficam temporariamente, um dos dois nao vai ter refcount
    -- guardar ponteiros locais como gordos com refcounts, na hora de sair do escopo, apaga o que for necessario

-- o cleanpup tem que ser só na referencia com o escopo mais externo que contem o valor
-- no caso acima, o 2/3 estariam guardados no arg

a = 2
b = 3
x = max(a,b)    -- nesse caso seria a/b
ou seja, as referencias gordas fortes sao aquelas que tem pelo menos 1 construtor!!!

se é uma atribuicao, entao a ref forte é a variável
se não é uma atribuicao, entao a ref forte é "arg"

struct REC_Cons {
    bool returned = 0;  // did not return ultimately // 1 when actually returned (return sets all)
    void* val;          // pointer to actual value
}
REC_ALIAS is pointer to REC_CONS
    - I know it is weak so I deref

c = Succ(b)     -- agora C e B tem que ser testados ao sair, se ambos = 0, entao pode desalocar o B
                -- ou seja vu precisar de uma lista p/ cada REC_CONS com outras REC_CONSs que ela aponta

// Also mark all REC_CONS references, which are those with EXPR_CONS.
//  - REC_CONS  escape and is root of some constructor
//  - REC_ALIAS escape but is not root of some constructor, instead they point to REC_CONS

vou precisar de refcount

1. detectar todos EXPR_VAR atingíveis por STMT_RET
    - os outros não precisa se preocupar, pois vão ser desalocados com os pools locais saindo de escopo
        - TODO: como nao desalocar mallocs mais externos em um pool local?
            - val x[]: Nat = Succ(a)    -- a é uma local retornada
            - return a
            - esse codigo tem que ser recusado
                - se "a" é alocado com malloc (com pool_alloc nao tem problema pq consigo detectar o pool original)
                - sao dois mallocs para raizes diferentes
                    - a partir das raizes, nao teria como diferenciar se estao ou nao em outra raiz
                    - entao tenho que recusar
                    - nao posso nunca compartilhar referencias que moram em pools de malloc
                        - precisa copiar
                        - funcao copy especial
2. para cada um deles X
    - verificar se tem um construtor em INIT
        - se nao tem, ignora esse
    - se tem, ele é REC_CONS
        1. antes do return tem que setar bit=1
        - olhar o INIT e pegar todos os EXPR_VAR Y recursivamente com passo 2
        2. esse X tem que ir pra lista do Y
3. detectar todos os STMT_VAR que tem construtor em INIT
    - para cada um deles Y
        - fazer um cleanup que percorre a sua lista de Xs que me acessam Y
            - se todos estao com bit=0, entao posso desalocar a minha arvore

val x[]         -- REC_POOL  esse nao precisa ser testado, nao se mistura
val y = p       -- REC_ALIAS esses dois preciso testar dinamicamente
val z = Cons    -- REC_CONS  eles se misturam na situacao acima


-- uma outra alternativa seria GC na saida de cada funcao:
    - percorrer a arvore inteira a partir da raiz

-- TODO-1
-- ESTATICO: detectar qd pool é declarado mas valores nao vao pra ele:
val x[]: Nat = three    -- aqui é uma global declarada em escopo maior
                        -- na verdade isso nao é um erro, a alocacao nao vai acontecer
                        -- poderia ser um warning pois *so* temos coisas desnecessarias

-- ERR
func f: () -> Nat {
    val x[]: Nat = Nil  -- (ln 5, col 9): invalid pool : data returns
    return x
}


