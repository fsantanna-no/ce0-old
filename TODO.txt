- posso passar uma REF onde espero um plain

- descobri as diferencas
    1. ce nao tem foco em mut: concorrencia/write-while-reading/iterator
        - problema ortogonal
    2. ADTs em rust sao ruins
    3. Rust nao consegue mover partes de estruturas recursivas
    4. Ce terá pools (pool xs[]:Nat ; var x:Nat in xs = ...)
        4.1 Limita escopo da memória
            - o sistema de ownership não respeita escopo mínimo, sempre posso retornar.
            - confusão com entendimento da memória em determinado momento
            - ter um ponteiro único nao ajuda necessariamente a entender
        4.2 Permite bounded pool
- closures explicitas precisa de new+ref para tuplas

- check_txs nao avalia funcoes que acessam ambiente externo
    - talvez já sim, pois EXPR_CALL chama body

- plains: copy
- references:
    - root / owner / strong
    - alias / borrow / weak
- VAL_PLAIN=0, VAL_REF_ROOT, VAL_REF_ALIAS

var x: Int              -- plain
var x: Int = new 10     -- root
var x: Int& = &y        -- alias
var x: Int in xs = new 10     -- root

- borrow vs access

- How to detect if EXPR_ALIAS is unsafe?
    1. For each EXPR_ALIAS
    2. Start from declaration and go towards EXPR_ALIAS
    3. Find any other EXPR_VAR.istx for the same EXPR_ALIAS->EXPR_VAR

- pega todos os acessos istx

- clone
- STMT_SET
    - var, ---swap--- move semantics
- tests TODO
- book

- CHECKS
    - ALIAS output
    - type mismatch: expected vs have

- POOLS
    - testar nao caber no pool
    - id()
        func f: () -> Nat {
            var x: Nat = ...
            return id(x)    -- does not return x, but pass x to id which might return it
        }                   -- solution is to make x also go to the pool
        var x[] = f()
    - can't return tuples w/ multiple rec types
    -- TODO-1: warning minor issue

- RECS
    - remover keyword rec?
    - f : () -> (Nat,List)
    - x[]: (Nat,List) = f()
        - funcao retornar dois recs
        - mas o retorno tem que ser uma variavel só que em teoria teria que guardar os dois recs no mesmo pool?

- MINOR
    - ref x: Nat
        - lista na pilha que deve ser percorrida sempre que ha um free
    - subtypes
        - var x: True = True
    - https://www.google.com/search?q=same-fringe+problem
        - https://www.lua.org/doc/jai2009.pdf
    - type Expr: (n:Int,env:Env) {
        Tuple: (size:Int, vec:[Expr])
        Stmt: (...)
      }
    - named tuples (struct/record) (Int,Int) --> (x:Int,y:Int)
    - input function polymorphic
    - -Wno-format-zero-length
    - types.c
        - verify duplicates for types/subtypes/vars/funcs
        - verify assigns, calls args/ret
    - funcoes as values (now we have ENV:var,func,type)
    - funcoes recursivas
        - special rec syntax
        - change env before body
    - assert no EXPR_DISC (gerar erro caso nao seja do subtipo certo)
    - type names must contain lowercase (error in C generation upper/lower)
    - output/input for strings, output_type/input_type for users
    - #define UNIT 1 // #define Unit int
    - repl
        - prevent side effect of expr to be lost:
            - _1 = exp ; output(_1);
        - >>> if not finished
    - Exceptions:
        - https://www.programmersought.com/article/404520682/
        - https://www.usenix.org/legacy/publications/library/proceedings/sa92/moen.pdf

- Ce0
    - implemented in C
    - simplest possible
    - immutable
- Ce
    - implemented in Ce0
    - mutable
    - type inference
    - pattern matching
    - lambdas
    - synchronous concurrency

1. scope of &x <= x
2. not both at the same time:
    - one or more references (&T) to a resource
    - exactly one mutable reference (&mut T)

void *heap_locations;
void *stack_location;

void determine_locations (int any_int) {
   free(heap_location = malloc(248));
   stack_location = &any_int;
}

int main(int argc, char *argv[]) {
  determine_locations(argc);
      .
      .
      .
  return 0;
}

<!--
- full previous


var y[]: Nat = Succ(f())

- further examples: add inside, add outside
```
func f: () -> Nat {
    var x: Nat = Succ(Succ(Nil))
    var y: Nat = Succ(Succ(Nil))
    var z: Nat = add(x,y)
    return z
}
var y[]: Nat = f()
```
```
func f: () -> Nat {
    var x: Nat = Succ(Succ(Nil))
    var y: Nat = Succ(Succ(Nil))
    var z: Nat = add(x,y)
    return z
}
var y[]: Nat = add(two,f())
```
-->

-- DINAMICO detectar quando ponteiros nao sao retornados e assim desalocar sua arvore na saida

func max: (Nat,Nat) -> Nat {
    -- arg e x e y sao gordos, todos com bit desligado
    var x: Nat = arg.1  -- no cleanup eu testo o bit e desaloco geral se tiver desligado
    var y: Nat = arg.2
    if x > y {
        return x        -- x+1 (liga bit)
    } else {
        return y        -- y+1 (liga bit)
    }
}

x = max(2,3)    -- 2 e 3 ficam temporariamente, um dos dois nao vai ter refcount
    -- guardar ponteiros locais como gordos com refcounts, na hora de sair do escopo, apaga o que for necessario

-- o cleanpup tem que ser só na referencia com o escopo mais externo que contem o valor
-- no caso acima, o 2/3 estariam guardados no arg

a = 2
b = 3
x = max(a,b)    -- nesse caso seria a/b
ou seja, as referencias gordas fortes sao aquelas que tem pelo menos 1 construtor!!!

se é uma atribuicao, entao a ref forte é a variável
se não é uma atribuicao, entao a ref forte é "arg"

struct REC_Cons {
    bool returned = 0;  // did not return ultimately // 1 when actually returned (return sets all)
    void* var;          // pointer to actual value
}
REC_ALIAS is pointer to REC_CONS
    - I know it is weak so I deref

c = Succ(b)     -- agora C e B tem que ser testados ao sair, se ambos = 0, entao pode desalocar o B
                -- ou seja vu precisar de uma lista p/ cada REC_CONS com outras REC_CONSs que ela aponta

// Also mark all REC_CONS references, which are those with EXPR_CONS.
//  - REC_CONS  escape and is root of some constructor
//  - REC_ALIAS escape but is not root of some constructor, instead they point to REC_CONS

vou precisar de refcount

1. detectar todos EXPR_VAR atingíveis por STMT_RET
    - os outros não precisa se preocupar, pois vão ser desalocados com os pools locais saindo de escopo
        - TODO: como nao desalocar mallocs mais externos em um pool local?
            - var x[]: Nat = Succ(a)    -- a é uma local retornada
            - return a
            - esse codigo tem que ser recusado
                - se "a" é alocado com malloc (com pool_alloc nao tem problema pq consigo detectar o pool original)
                - sao dois mallocs para raizes diferentes
                    - a partir das raizes, nao teria como diferenciar se estao ou nao em outra raiz
                    - entao tenho que recusar
                    - nao posso nunca compartilhar referencias que moram em pools de malloc
                        - precisa copiar
                        - funcao copy especial
2. para cada um deles X
    - verificar se tem um construtor em INIT
        - se nao tem, ignora esse
    - se tem, ele é REC_CONS
        1. antes do return tem que setar bit=1
        - olhar o INIT e pegar todos os EXPR_VAR Y recursivamente com passo 2
        2. esse X tem que ir pra lista do Y
3. detectar todos os STMT_VAR que tem construtor em INIT
    - para cada um deles Y
        - fazer um cleanup que percorre a sua lista de Xs que me acessam Y
            - se todos estao com bit=0, entao posso desalocar a minha arvore

var x[]         -- REC_POOL  esse nao precisa ser testado, nao se mistura
var y = p       -- REC_ALIAS esses dois preciso testar dinamicamente
var z = Cons    -- REC_CONS  eles se misturam na situacao acima


-- uma outra alternativa seria GC na saida de cada funcao:
    - percorrer a arvore inteira a partir da raiz

-- TODO-1
-- ESTATICO: detectar qd pool é declarado mas valores nao vao pra ele:
var x[]: Nat = three    -- aqui é uma global declarada em escopo maior
                        -- na verdade isso nao é um erro, a alocacao nao vai acontecer
                        -- poderia ser um warning pois *so* temos coisas desnecessarias

-- ERR
func f: () -> Nat {
    var x[]: Nat = Nil  -- (ln 5, col 9): invalid pool : data returns
    return x
}


