native pre _{
    #include <string.h>
}

native _{
    FILE* stropen (const char* mode, size_t size, char* str) {
        size = (size != 0) ? size : strlen(str);
        return fmemopen(str, size, mode);
    }
}

native _{
    typedef enum {
        TK_ERR = 0,

        TK_SINGLE = 256,   // all single-char tokens

        TK_EOF,
        TK_ARROW,
        TK_UNIT,

        TX_NATIVE,
        TX_VAR,
        TX_NULL,
        TX_USER,
        TX_NUM,

        TK_RESERVED,    // all reserved keywords
        //TK_ARG,
        TK_BREAK,
        TK_CALL,
        //TK_CLONE,
        TK_ELSE,
        TK_FUNC,
        TK_IF,
        TK_INPUT,
        TK_LOOP,
        TK_NATIVE,
        TK_OUTPUT,
        TK_PRE,
        TK_REC,
        TK_RETURN,
        TK_SET,
        TK_TYPE,
        TK_VAR
    } TK;
}

native _{
    typedef char Str_Buf[256];
}

type TK_Val {
    Num: Int
    Str: _Str_Buf
}

type Bool {
    False: ()
    True:  ()
}

func asbool: Int -> Bool {
    return _(arg ? (Bool){True} : (Bool){False})
}

var inp: _(FILE*) = ?
var lin: Int = ?
var col: Int = ?
var tk0: (Int,TK_Val,Int,Int) = ?   -- enu, val, lin, col
var tk1: (Int,TK_Val,Int,Int) = ?   -- enu, val, lin, col

func lx_blanks: () -> () {
    loop {
        var c: Int = _fgetc _inp
        if asbool _(c == '-') {
            set c = _fgetc _inp
            if asbool _(c == '-') {                 -- ignore comments
                set col = _(col + 1)
                set col = _(col + 1)
                loop {
                    set c = _fgetc _inp
                    if asbool _(c == EOF) {         -- EOF stops comment
                        break
                    }
                    if asbool _(c == '\n') {        -- LN stops comment
                        native _(ungetc(c, inp);)
                        break
                    }
                    set col = _(col + 1)
                }
            } else {
                native _(ungetc(c, inp);)
                native _(ungetc('-', inp);)
                return ()
            }
        } else {
            if asbool _(c == '\n') {                -- ignore new lines
                set lin = _(lin + 1)
                set col = 0
            } else {
                if asbool _(c == ' ') {             -- ignore new spaces
                    set col = _(col + 1)
                } else {
                    native _(ungetc(c, inp);)
                    return ()
                }
            }
        }
    }
}

func lx_token: () -> () {
    var c: Int = _fgetc _inp

    if asbool _{c=='{' || c=='}' || c==')'  || c==';' || c==':' || c=='=' ||
                c==',' || c=='.' || c=='\\' || c=='!' || c=='?'}
    {
        set tk1.1 = c
        return ()
    }

    if asbool _(c == EOF) {
        set tk1.1 = _TK_EOF
        return ()
    }

    if asbool _{c == '('} {
        set c = _fgetc _inp
        if asbool _{c == ')'} {
            set tk1.2 = Str ?
            native _{strcpy(tk1._2._Str, "()");}
            set tk1.1 = _TK_UNIT
        }
        native _(ungetc(c, inp);)
        set tk1.1 = _{'('}
        return ()
    }

    if asbool _(c == '-') {
        set c = _fgetc _inp
        if asbool _(c == '>') {
            set tk1.1 = _TK_ARROW
            return ()
        }
    }

    call _assert 0
}

func lexer: () -> () {
    call lx_blanks ()
    call lx_token  ()
    call lx_blanks ()
}

func t_lexer: () -> () {
    -- COMMENTS
    {
        set inp = _{stropen("r", 0, "--foobar")}
        {
            var c: Int = call _fgetc inp
            native _(assert(c == '-');)
            native _(ungetc(c,inp);)
        }
        {
            call lx_blanks ()
            var c: Int = call _fgetc inp
            native _(assert(c == EOF);)
        }
        call _fclose inp
    }
    {
        set inp = _{stropen("r", 0, "-- foobar")}
        set lin = 1;
        set col = 1;
        call lx_blanks ()
        native _(assert(lin == 1);)
        native _(assert(col == 10);)
        call _fclose inp
    }
    {
        set inp = _{stropen("r", 0, "-- c1\n--c2\n\n")}
        set lin = 1;
        set col = 1;
        call lx_blanks ()
        native _(assert(lin == 4);)
        native _(assert(col == 0);)
        call _fclose inp
    }

    -- SYMBOLS
    {
        set inp = _{stropen("r", 0, "( -> ,")}
        set lin = 1;
        set col = 1;
        call lexer () ; native _{assert(tk1._1 == '(');}
        call lexer () ; native _{assert(tk1._1 == TK_ARROW);}
        call lexer () ; native _{assert(tk1._1 == ',');}
        call _fclose inp
    }
    {
        set inp = _(stropen("r", 0, ": }{ :"))
        set lin = 1;
        set col = 1;
        call lexer () ; native _(assert(tk1._1 == ':');)
        call lexer () ; native _(assert(tk1._1 == '}');)
        call lexer () ; native _(assert(tk1._1 == '{');)
        call lexer () ; native _(assert(tk1._1 == ':');)
        call _fclose inp
    }
}

call t_lexer ()
