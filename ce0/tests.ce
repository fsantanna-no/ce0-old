type Bool {
    False: ()
    True:  ()
}

func not: Bool -> Bool {
    if arg {
        return False
    } else {
        return True
    }
}

func asbool: Int -> Bool {
    return _(arg ? (Bool){True} : (Bool){False})
}

native pre _{
    #include <string.h>
    #include <ctype.h>
}

native _{
    FILE* stropen (const char* mode, size_t size, char* str) {
        size = (size != 0) ? size : strlen(str);
        return fmemopen(str, size, mode);
    }
}

native _{
    typedef enum {
        TK_ERR = 0,

        TK_SINGLE = 256,   // all single-char tokens

        TK_EOF,
        TK_ARROW,
        TK_UNIT,

        TX_NATIVE,
        TX_VAR,
        TX_NULL,
        TX_USER,
        TX_NUM,

        TK_RESERVED,    // all reserved keywords
        //TK_ARG,
        TK_BREAK,
        TK_CALL,
        //TK_CLONE,
        TK_ELSE,
        TK_FUNC,
        TK_IF,
        TK_INPUT,
        TK_LOOP,
        TK_NATIVE,
        TK_OUTPUT,
        TK_PRE,
        TK_REC,
        TK_RETURN,
        TK_SET,
        TK_TYPE,
        TK_VAR
    } TK;
}

native _{
    static char* reserved[] = {
        //"arg",
        "break",
        "call",
        //"clone",
        "else",
        "func",
        "if",
        "input",
        //"Int",
        "loop",
        "native",
        "output",
        "pre",
        "rec",
        "return",
        "set",
        //"Std",
        "type",
        "var"
    };
}

native _{
    #define ERR_BUF 256
    #define TK_BUF 1024
    typedef char Str_Buf[TK_BUF];
    typedef char Err_Buf[ERR_BUF];
}

type TK_Val {
    Num: Int
    Str: _Str_Buf
}

func is_reserved: \TK_Val -> Int {
    var n: Int = _(sizeof(reserved) / sizeof(reserved[0]))
    var i: Int = 0
    loop {
        var str: _(char*) = arg\.Str!
        if asbool _(!strcmp(str, reserved[i])) {
            return _(TK_RESERVED+1 + i)
        }
        set i = _(i + 1)
        if asbool _(i == n) {
            break
        }
    }
    return 0;
}

var inp: _(FILE*) = ?
var lin: Int = ?
var col: Int = ?
var tk0: (Int,TK_Val,Int,Int) = ?   -- enu, val, lin, col
var tk1: (Int,TK_Val,Int,Int) = ?   -- enu, val, lin, col
var err: _Err_Buf = ?

-------------------------------------------------------------------------------

func lexer_tk2str: (Int,TK_Val,Int,Int) -> _(const char*) {
    native _{ static char str[TK_BUF+256]; }
    if asbool _(arg._1 == TK_EOF) {
        native _{ sprintf(str, "end of file"); }
        return _str
    }
    if asbool _(arg._1 == TK_UNIT) {
        native _{ sprintf(str, "`()´"); }
        return _str
    }
    if asbool _(arg._1 == TX_NATIVE) {
        native _{ sprintf(str, "\"_%s\"", arg._2._Str); }
        return _str
    }
    if asbool _(arg._1 == TX_NUM) {
        native _{ sprintf(str, "\"%d\"", arg._2._Num); }
        return _str
    }
    if asbool _(arg._1==TX_VAR || arg._1==TX_USER || arg._1==TX_NULL || arg._1==TK_ERR) {
        native _{ sprintf(str, "\"%s\"", arg._2._Str); }
        return _str
    }
    if asbool _(arg._1>0 && arg._1<TK_SINGLE) {
        native _{ sprintf(str, "`%c´", arg._1); }
        return _str
    }
    if asbool _(arg._1 > TK_RESERVED) {
        native _{ sprintf(str, "`%s´", reserved[arg._1-TK_RESERVED-1]); }
        return _str
    }
    call _assert 0
}

func lx_blanks: () -> () {
    loop {
        var c: Int = _fgetc _inp
        if asbool _(c == '-') {
            set c = _fgetc _inp
            if asbool _(c == '-') {                 -- ignore comments
                set col = _(col + 1)
                set col = _(col + 1)
                loop {
                    set c = _fgetc _inp
                    if asbool _(c == EOF) {         -- EOF stops comment
                        break
                    }
                    if asbool _(c == '\n') {        -- LN stops comment
                        native _(ungetc(c, inp);)
                        break
                    }
                    set col = _(col + 1)
                }
            } else {
                native _(ungetc(c, inp);)
                native _(ungetc('-', inp);)
                return ()
            }
        } else {
            if asbool _(c == '\n') {                -- ignore new lines
                set lin = _(lin + 1)
                set col = 1
            } else {
                if asbool _(c == ' ') {             -- ignore new spaces
                    set col = _(col + 1)
                } else {
                    native _(ungetc(c, inp);)
                    return ()
                }
            }
        }
    }
}

func lx_token: () -> () {
    var c: Int = _fgetc _inp

    -- SYMBOLS
    if asbool _{c=='{' || c=='}' || c==')'  || c==';' || c==':' || c=='=' ||
                c==',' || c=='.' || c=='\\' || c=='!' || c=='?'}
    {
        set tk1.1 = c
        return ()
    }

    -- EOF
    if asbool _(c == EOF) {
        set tk1.1 = _TK_EOF
        return ()
    }

    -- '(', TK_UNIT
    if asbool _{c == '('} {
        set c = _fgetc _inp
        if asbool _{c == ')'} {
            set tk1.2 = Str ?
            native _{strcpy(tk1._2._Str, "()");}
            set tk1.1 = _TK_UNIT
            return ()
        }
        native _(ungetc(c, inp);)
        set tk1.1 = _{'('}
        return ()
    }

    -- TK_ARROW
    if asbool _(c == '-') {
        set c = _fgetc _inp
        if asbool _(c == '>') {
            set tk1.1 = _TK_ARROW
            return ()
        }
        call _assert 0
    }

    -- TX_NATIVE
    if asbool _(c == '_') {
        set c = _fgetc _inp
        var open: Int = 0
        var close: Int = 0
        var open_close: Int = 0
        if asbool _(c=='(' /*)*/ || c=='{') {
            set open  = c;
            if asbool _{c == '('} {
                set close = _{')'}
            } else {
                set close = _('}')
            }
            set c = _fgetc _inp
            set open_close = _(open_close + 1)
        }

        var i: Int = 0
        loop {
            if asbool _(!close && !isalnum(c) && c!='_') {
                break
            }
            if asbool _(c == open) {
                set open_close = _(open_close + 1)
            } else {
                if asbool _(c == close) {
                    set open_close = _(open_close - 1)
                    if asbool _(open_close == 0) {
                        break;
                    }
                }
            }
            native _{ tk1._2._Str[i] = c; }
            set i = _(i + 1)
            if asbool _(c == '\n') {
                set lin = _(lin + 1)
            }
            set c = _fgetc _inp
            call _assert _(i < TK_BUF)
        }

        native _{ tk1._2._Str[i] = '\0'; }
        if asbool _(!close) {
            native _(ungetc(c, inp);)
        }

        set tk1.1 = _TX_NATIVE
        return ()
    }

    set tk1.2 = Str ?

    -- TX_NUM
    if asbool _(isdigit(c)) {
        var i: Int = 0
        loop {
            if asbool _(!isalnum(c)) {
                break
            }
            if asbool _(isdigit(c)) {
                native _{ tk1._2._Str[i] = c; }
                set i = _(i + 1)
                call _assert _(i < TK_BUF)
            } else {
                native _{ tk1._2._Str[i] = '\0'; }
                set tk1.1 = _TK_ERR
                return ()
            }
            set c = _fgetc _inp
        }
        native _{ tk1._2._Str[i] = '\0'; }
        set tk1.2 = Num _atoi tk1.2.Str!
        native _(ungetc(c, inp);)
        set tk1.1 = _TX_NUM
        return ()
    }

    -- TX_VAR, TX_USER
    if asbool _(isalpha(c)) {
        var i: Int = 0
        loop {
            if asbool _(!isalnum(c) && c!='_') {
                break
            }
            native _{ tk1._2._Str[i] = c; }
            set i = _(i + 1)
            call _assert _(i < TK_BUF)
            set c = _fgetc _inp
        }
        native _{ tk1._2._Str[i] = '\0'; }
        native _(ungetc(c, inp);)

        var key: Int = call is_reserved(\tk1.2)
        if asbool _(key != 0) {
            set tk1.1 = key
            return ()
        }

        -- TX_VAR
        if asbool _(islower(tk1._2._Str[0])) {
            set tk1.1 = _TX_VAR
            return ()
        }

        -- TX_USER
        if asbool _(isupper(tk1._2._Str[0])) {
            set tk1.1 = _TX_USER
            return ()
        }
        call _assert 0
    }

    call _assert 0
}

func lexer: () -> () {
    set tk0 = tk1
    call lx_blanks ()
    set tk1.3 = lin
    set tk1.4 = col
    var bef: Int = call _ftell inp
    call lx_token  ()
    set col = _(col + (ftell(inp) - bef))
    call lx_blanks ()
}

-------------------------------------------------------------------------------

type pre Type

type rec List_Type {
    Item_Type: (Type, List_Type)
}

type rec Type {                             -- CE1: subtype isrec=Bool
    Type_Any:    Bool
    Type_Unit:   Bool
    Type_Native: (Bool, (Int,TK_Val,Int,Int))
    Type_User:   (Bool, (Int,TK_Val,Int,Int))
    Type_Tuple:  (Bool, List_Type)
    Type_Func:   (Bool, Type, Type)
}

type Maybe_Type {
    Type_None: ()
    Type_Some: Type
}

func accept: _TK -> Bool {
    if asbool _(tk1._1 == arg) {
        call lexer ()
        return True
    } else {
        return False
    }
}

func err_expected: _(const char*) -> () {
    native _{ sprintf(err, "(ln %d, col %d): expected %s : have %s",
        tk1._3, tk1._4, arg, lexer_tk2str(tk1)); }
}

func parser_type: () -> Maybe_Type {
--native _{ printf(">>> %d\n", tk1._1); }
    var isalias: Bool = call accept _('\\')

    -- TYPE_UNIT
    if accept _TK_UNIT {
        return Type_Some Type_Unit isalias
    }

    -- TYPE_NATIVE
    if accept _TX_NATIVE {
        return Type_Some Type_Native (isalias, tk0)
    }

    -- TYPE_PARENS / TYPE_TUPLE
    if accept _{'('} {
        var tmp: Maybe_Type = call parser_type ()
        if tmp.Type_None? {
            return Type_None
        }

        -- TYPE_PARENS
        if accept _{')'} {
            return tmp
        }

        -- TYPE_TUPLE
        var lst: List_Type = Item_Type (tmp.Type_Some!, $List_Type)
        {
            var cur: \List_Type = \lst
            loop {
                if not accept _(',') {
                    break
                }
                var tmp: Maybe_Type = call parser_type ()
                if tmp.Type_None? {
                    return Type_None
                }
                set cur\.Item_Type! = (tmp.Type_Some!, $List_Type)
                set cur = \cur\.Item_Type!.2
            }
        }

        if not accept _{')'} {
            return Type_None
        }

        return Type_Some Type_Tuple (isalias,lst)
    }

    call err_expected _("type")
    return Type_None
}

-------------------------------------------------------------------------------

func t_lexer: () -> () {
    -- COMMENTS
    {
        set inp = _{stropen("r", 0, "--foobar")}
        {
            var c: Int = call _fgetc inp
            native _(assert(c == '-');)
            native _(ungetc(c,inp);)
        }
        {
            call lx_blanks ()
            var c: Int = call _fgetc inp
            native _(assert(c == EOF);)
        }
        call _fclose inp
    }
    {
        set inp = _{stropen("r", 0, "-- foobar")}
        set lin = 1;
        set col = 1;
        call lx_blanks ()
        native _(assert(lin == 1);)
        native _(assert(col == 10);)
        call _fclose inp
    }
    {
        set inp = _{stropen("r", 0, "-- c1\n--c2\n\n")}
        set lin = 1;
        set col = 1;
        call lx_blanks ()
        native _(assert(lin == 4);)
        native _(assert(col == 1);)
        call _fclose inp
    }

    -- SYMBOLS
    {
        set inp = _{stropen("r", 0, "( -> ,")}
        set lin = 1;
        set col = 1;
        call lexer () ; native _{assert(tk1._1 == '(');}
        call lexer () ; native _{assert(tk1._1 == TK_ARROW);}
        call lexer () ; native _{assert(tk1._1 == ',');}
        call _fclose inp
    }
    {
        set inp = _(stropen("r", 0, ": }{ :"))
        set lin = 1;
        set col = 1;
        call lexer () ; native _(assert(tk1._1 == ':');)
        call lexer () ; native _(assert(tk1._1 == '}');)
        call lexer () ; native _(assert(tk1._1 == '{');)
        call lexer () ; native _(assert(tk1._1 == ':');)
        call _fclose inp
    }

    -- KEYWORDS
    {
        set inp = _(stropen("r", 0, "xvar var else varx type"))
        set lin = 1;
        set col = 1;
        call lexer () ; native _(assert(tk1._1 == TX_VAR);)
        call lexer () ; native _(assert(tk1._1 == TK_VAR);)
        call lexer () ; native _(assert(tk1._1 == TK_ELSE);)
        call lexer () ; native _(assert(tk1._1 == TX_VAR);)
        call lexer () ; native _(assert(tk1._1 == TK_TYPE);)
        call _fclose inp
    }

    -- TX_VAR / TX_USER
    {
        set inp = _(stropen("r", 0, "c1\nc2 c3  \n    \nc4"))
        set lin = 1;
        set col = 1;
        call lexer () ; native _{
            assert(tk1._1 == TX_VAR);
            assert(!strcmp(tk1._2._Str,"c1"));
            assert(tk1._3 == 1);
            assert(tk1._4 == 1);
        }
        call lexer () ; native _{
            assert(tk1._1 == TX_VAR);
            assert(!strcmp(tk1._2._Str,"c2"));
            assert(tk1._3 == 2);
            assert(tk1._4 == 1);
        }
        call lexer () ; native _{
            assert(tk1._1 == TX_VAR);
            assert(!strcmp(tk1._2._Str,"c3"));
            assert(tk1._3 == 2);
            assert(tk1._4 == 4);
        }
        call lexer () ; native _{
            assert(tk1._1 == TX_VAR);
            assert(!strcmp(tk1._2._Str,"c4"));
            assert(tk1._3 == 4);
            assert(tk1._4 == 1);
        }
        call _fclose inp
    }
    {
        set inp = _(stropen("r", 0, "c1 C1 Ca a C"))
        set lin = 1;
        set col = 1;
        call lexer () ; native _{
            assert(tk1._1 == TX_VAR);
            assert(!strcmp(tk1._2._Str,"c1"));
            assert(tk1._3 == 1);
            assert(tk1._4 == 1);
        }
        call lexer () ; native _{
            assert(tk1._1 == TX_USER);
            assert(!strcmp(tk1._2._Str,"C1"));
            assert(tk1._3 == 1);
            assert(tk1._4 == 4);
        }
        call lexer () ; native _{
            assert(tk1._1 == TX_USER);
            assert(!strcmp(tk1._2._Str,"Ca"));
            assert(tk1._3 == 1);
            assert(tk1._4 == 7);
        }
        call lexer () ; native _{
            assert(tk1._1 == TX_VAR);
            assert(!strcmp(tk1._2._Str,"a"));
            assert(tk1._3 == 1);
            assert(tk1._4 == 10);
        }
        call lexer () ; native _{
            assert(tk1._1 == TX_USER);
            assert(!strcmp(tk1._2._Str,"C"));
            assert(tk1._3 == 1);
            assert(tk1._4 == 12);
        }
        call _fclose inp
    }

    -- TX_NATIVE
    {
        set inp = _(stropen("r", 0, "_char _Tp"))
        set lin = 1;
        set col = 1;
        call lexer () ; native _{
            assert(tk1._1 == TX_NATIVE);
            assert(!strcmp(tk1._2._Str,"char"));
        }
        call _fclose inp
    }
    {
        set inp = _(stropen("r", 0, "_{(1)} _(2+2)"))
        set lin = 1;
        set col = 1;
        call lexer () ; native _{
            assert(tk1._1 == TX_NATIVE);
            assert(!strcmp(tk1._2._Str,"(1)"));
        }
        call lexer () ; native _{
            assert(tk1._1 == TX_NATIVE);
            assert(!strcmp(tk1._2._Str,"2+2"));
        }
        call _fclose inp
    }

    -- TX_NUM
    {
        set inp = _(stropen("r", 0, ".1a"))
        set lin = 1;
        set col = 1;
        call lexer () ; native _{
            assert(tk1._1 == '.');
        }
        call lexer () ; native _{
            assert(tk1._1 == TK_ERR);
        }
        call _fclose inp
    }
    {
        set inp = _(stropen("r", 0, ".10"))
        set lin = 1;
        set col = 1;
        call lexer () ; native _{
            assert(tk1._1 == '.');
        }
        call lexer ()
        call _assert _(tk1._1 == TX_NUM)
        var n: Int = tk1.2.Num!
        call _assert _(n == 10)
        call _fclose inp
    }
}

func t_parser_type: () -> () {
    -- ERROR
    {
        set inp = _(stropen("r", 0, "xxx"))
        set lin = 1;
        set col = 1;
        call lexer ()
        var ret: Maybe_Type = call parser_type ()
        var ok: Bool = ret.Type_None?
        call _assert _(ok.sub)
        call _assert _{!strcmp(err,"(ln 1, col 1): expected type : have \"xxx\"")}
        call _fclose inp
    }
    -- TYPE_UNIT
    {
        set inp = _(stropen("r", 0, "()"))
        set lin = 1;
        set col = 1;
        call lexer ()
        var ret: Maybe_Type = call parser_type ()
        var ok: Bool = ret.Type_Some?
        var tp: Bool = ret.Type_Some!.Type_Unit?
        call _assert _(ok.sub && tp.sub)
        call _fclose inp
    }
    -- TYPE_NATIVE
    {
        set inp = _(stropen("r", 0, "_char"))
        set lin = 1;
        set col = 1;
        call lexer ()
        var ret: Maybe_Type = call parser_type ()
        var ok: Bool = ret.Type_Some?
        var tp: Bool = ret.Type_Some!.Type_Native?
        var id: _(char*) = ret.Type_Some!.Type_Native!.2.2.Str!
        call _assert _(ok.sub && tp.sub)
        call _assert _(!strcmp(id,"char"))
        call _fclose inp
    }
    -- TYPE_TUPLE
    {
        set inp = _(stropen("r", 0, "((),_char)"))
        set lin = 1;
        set col = 1;
        call lexer ()
        var ret: Maybe_Type = call parser_type ()
        var tup: (Bool,List_Type) = ret.Type_Some!.Type_Tuple!
        var nat: _(char*) = tup.2.Item_Type!.1.Type_Native!.2.2.Str!
        var ok: Bool = tup.2.Item_Type!.2.$List_Type?
        call _assert _(ok.sub && !strcmp(nat,"char"))
        call _fclose inp
    }
}

call t_lexer  ()
call t_parser_type ()
